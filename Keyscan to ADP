"""
Keyscan Aurora â†’ ADP Workforce Now (Time Entries Modify)

STATUS:
- DRY_RUN enabled
- No ADP writes will occur
- Payload is generated and saved for review

REQUIRES:
- Python 3.10+
- pandas
- requests
"""

from __future__ import annotations

import os
import re
import csv
import json
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple

import pandas as pd
import requests


# ============================
# CONFIGURATION
# ============================

KEYSCAN_INPUT_PATH = "samples/dataset.xlsx"
MAPPING_CSV_PATH = "mapping/mapping.csv"
OUTPUT_PAYLOAD_PATH = "output/adp_payload.json"

DRY_RUN = True  # MUST remain True until AOID/PFID mapping exists

ADP_BASE_URL = os.getenv("ADP_BASE_URL", "https://api.adp.com")
ADP_ACCESS_TOKEN = os.getenv("ADP_ACCESS_TOKEN", "")
ADP_ROLE_CODE = "practitioner"

IN_REGEX = re.compile(r"\(in\)", re.IGNORECASE)
OUT_REGEX = re.compile(r"\(out\)", re.IGNORECASE)

ALLOW_TOGGLE_PAIRING_IF_NO_OUT = True
MIN_SHIFT_MINUTES = 1


# ============================
# DATA MODELS
# ============================

@dataclass(frozen=True)
class WorkerMap:
    badge: str
    associate_oid: str
    work_assignment_id: str


@dataclass(frozen=True)
class ScanEvent:
    badge: str
    when: datetime
    direction: str
    location: str


@dataclass(frozen=True)
class TimePair:
    badge: str
    start: datetime
    end: datetime
    entry_id: str


# ============================
# LOADERS
# ============================

def load_mapping(path: str) -> Dict[str, WorkerMap]:
    if not os.path.exists(path):
        return {}

    mapping: Dict[str, WorkerMap] = {}
    with open(path, newline="", encoding="utf-8-sig") as f:
        reader = csv.DictReader(f)
        for row in reader:
            if not row.get("badge"):
                continue
            mapping[row["badge"]] = WorkerMap(
                badge=row["badge"],
                associate_oid=row["associateOID"],
                work_assignment_id=row["workAssignmentID"],
            )
    return mapping


def load_keyscan_events(path: str) -> List[ScanEvent]:
    df = pd.read_excel(path, header=5)

    df["DateTime"] = pd.to_datetime(df["DateTime"], errors="coerce")
    df = df.dropna(subset=["DateTime"])

    events: List[ScanEvent] = []

    for _, r in df.iterrows():
        loc = str(r["Location"])
        direction = "IN"
        if OUT_REGEX.search(loc):
            direction = "OUT"
        elif IN_REGEX.search(loc):
            direction = "IN"

        events.append(
            ScanEvent(
                badge=str(r["Credential_Number"]).strip(),
                when=r["DateTime"].to_pydatetime(),
                direction=direction,
                location=loc,
            )
        )

    events.sort(key=lambda e: (e.badge, e.when))
    return events


# ============================
# BUSINESS LOGIC
# ============================

def make_entry_id(badge: str, start: datetime, end: datetime) -> str:
    seed = f"{badge}|{start.isoformat()}|{end.isoformat()}"
    return str(uuid.uuid5(uuid.NAMESPACE_DNS, seed))


def pair_events(events: List[ScanEvent]) -> List[TimePair]:
    grouped: Dict[Tuple[str, str], List[ScanEvent]] = {}

    for e in events:
        day = e.when.strftime("%Y-%m-%d")
        grouped.setdefault((e.badge, day), []).append(e)

    pairs: List[TimePair] = []

    for (badge, _), evs in grouped.items():
        evs.sort(key=lambda e: e.when)
        has_out = any(e.direction == "OUT" for e in evs)

        if has_out:
            current_in: Optional[ScanEvent] = None
            for e in evs:
                if e.direction == "IN":
                    current_in = e
                elif e.direction == "OUT" and current_in:
                    pairs.append(
                        TimePair(
                            badge=badge,
                            start=current_in.when,
                            end=e.when,
                            entry_id=make_entry_id(badge, current_in.when, e.when),
                        )
                    )
                    current_in = None
        elif ALLOW_TOGGLE_PAIRING_IF_NO_OUT:
            for i in range(0, len(evs) - 1, 2):
                pairs.append(
                    TimePair(
                        badge=badge,
                        start=evs[i].when,
                        end=evs[i + 1].when,
                        entry_id=make_entry_id(badge, evs[i].when, evs[i + 1].when),
                    )
                )

    return pairs


def build_adp_payload(pairs: List[TimePair], mapping: Dict[str, WorkerMap]) -> dict:
    events = []
    event_id = 0

    for p in pairs:
        if p.badge not in mapping:
            continue

        wm = mapping[p.badge]

        events.append(
            {
                "eventID": event_id,
                "serviceCategoryCode": {"codeValue": "core"},
                "data": {
                    "eventContext": {
                        "associateOID": wm.associate_oid,
                        "workAssignmentID": wm.work_assignment_id,
                    },
                    "transform": {
                        "timeEntries": [
                            {
                                "itemID": 0,
                                "entryID": p.entry_id,
                                "entryTypeCode": {"codeValue": "timePair"},
                                "entryDate": p.start.strftime("%Y-%m-%d"),
                                "startPeriod": {
                                    "startDateTime": p.start.strftime("%Y-%m-%dT%H:%M:%S")
                                },
                                "endPeriod": {
                                    "endDateTime": p.end.strftime("%Y-%m-%dT%H:%M:%S")
                                },
                                "_changeCode": "add",
                            }
                        ]
                    },
                },
            }
        )
        event_id += 1

    return {"events": events}


# ============================
# MAIN
# ============================

def main() -> None:
    mapping = load_mapping(MAPPING_CSV_PATH)
    events = load_keyscan_events(KEYSCAN_INPUT_PATH)
    pairs = pair_events(events)
    payload = build_adp_payload(pairs, mapping)

    os.makedirs("output", exist_ok=True)
    with open(OUTPUT_PAYLOAD_PATH, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2)

    print("DRY RUN COMPLETE")
    print(f"Pairs generated: {len(pairs)}")
    print(f"Payload written to {OUTPUT_PAYLOAD_PATH}")


if __name__ == "__main__":
    main()

